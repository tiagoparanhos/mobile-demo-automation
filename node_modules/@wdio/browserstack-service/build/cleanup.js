// src/util.ts
import { hostname, platform, type, version, arch } from "node:os";
import fs4 from "node:fs";
import zlib from "node:zlib";
import { format, promisify } from "node:util";
import path3 from "node:path";
import util from "node:util";
import gitRepoInfo from "git-repo-info";
import gitconfig from "gitconfiglocal";
import { FormData } from "formdata-node";

// src/logPatcher.ts
import Transport from "winston-transport";
var LOG_LEVELS = {
  INFO: "INFO",
  ERROR: "ERROR",
  DEBUG: "DEBUG",
  TRACE: "TRACE",
  WARN: "WARN"
};
var logPatcher = class extends Transport {
  logToTestOps = (level = LOG_LEVELS.INFO, message = [""]) => {
    process.emit(`bs:addLog:${process.pid}`, {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level: level.toUpperCase(),
      message: `"${message.join(", ")}"`,
      kind: "TEST_LOG",
      http_response: {}
    });
  };
  /* Patching this would show user an extended trace on their cli */
  trace = (...message) => {
    this.logToTestOps(LOG_LEVELS.TRACE, message);
  };
  debug = (...message) => {
    this.logToTestOps(LOG_LEVELS.DEBUG, message);
  };
  info = (...message) => {
    this.logToTestOps(LOG_LEVELS.INFO, message);
  };
  warn = (...message) => {
    this.logToTestOps(LOG_LEVELS.WARN, message);
  };
  error = (...message) => {
    this.logToTestOps(LOG_LEVELS.ERROR, message);
  };
  log = (...message) => {
    this.logToTestOps(LOG_LEVELS.INFO, message);
  };
};
var logPatcher_default = logPatcher;

// src/performance-tester.ts
import { createObjectCsvWriter } from "csv-writer";
import fs2 from "node:fs";
import { performance, PerformanceObserver } from "node:perf_hooks";

// src/bstackLogger.ts
import path from "node:path";
import fs from "node:fs";
import chalk from "chalk";
import logger from "@wdio/logger";

// package.json
var package_default = {
  name: "@wdio/browserstack-service",
  version: "9.7.3",
  description: "WebdriverIO service for better Browserstack integration",
  author: "Adam Bjerstedt <abjerstedt@gmail.com>",
  homepage: "https://github.com/webdriverio/webdriverio/tree/main/packages/wdio-browserstack-service",
  license: "MIT",
  engines: {
    node: ">=18.20.0"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/webdriverio/webdriverio.git",
    directory: "packages/wdio-browserstack-service"
  },
  keywords: [
    "webdriverio",
    "wdio",
    "browserstack",
    "wdio-service"
  ],
  bugs: {
    url: "https://github.com/webdriverio/webdriverio/issues"
  },
  type: "module",
  types: "./build/index.d.ts",
  exports: {
    ".": {
      types: "./build/index.d.ts",
      import: "./build/index.js"
    },
    "./cleanup": {
      import: "./build/cleanup.js",
      source: "./src/cleanup.ts"
    }
  },
  typeScriptVersion: "3.8.3",
  dependencies: {
    "@browserstack/ai-sdk-node": "1.5.17",
    "@percy/appium-app": "^2.0.1",
    "@percy/selenium-webdriver": "^2.0.3",
    "@types/gitconfiglocal": "^2.0.1",
    "@wdio/logger": "workspace:*",
    "@wdio/reporter": "workspace:*",
    "@wdio/types": "workspace:*",
    "browserstack-local": "^1.5.1",
    chalk: "^5.3.0",
    "csv-writer": "^1.6.0",
    "formdata-node": "5.0.1",
    "git-repo-info": "^2.1.1",
    gitconfiglocal: "^2.1.0",
    uuid: "^10.0.0",
    webdriverio: "workspace:*",
    "winston-transport": "^4.5.0",
    yauzl: "^3.0.0"
  },
  peerDependencies: {
    "@wdio/cli": "^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0 || ^9.0.0"
  },
  devDependencies: {
    "@types/node": "^20.1.0",
    "@types/yauzl": "^2.10.3",
    "@wdio/globals": "workspace:*"
  },
  publishConfig: {
    access: "public"
  }
};

// src/constants.ts
var bstackServiceVersion = package_default.version;
var consoleHolder = Object.assign({}, console);
var DATA_ENDPOINT = "https://collector-observability.browserstack.com";
var BSTACK_SERVICE_VERSION = bstackServiceVersion;
var LOGS_FILE = "logs/bstack-wdio-service.log";
var FUNNEL_INSTRUMENTATION_URL = "https://api.browserstack.com/sdk/v1/event";
var BROWSERSTACK_TESTHUB_JWT = "BROWSERSTACK_TESTHUB_JWT";
var TESTOPS_SCREENSHOT_ENV = "BS_TESTOPS_ALLOW_SCREENSHOTS";
var BROWSERSTACK_TESTHUB_UUID = "BROWSERSTACK_TESTHUB_UUID";
var PERF_MEASUREMENT_ENV = "BROWSERSTACK_O11Y_PERF_MEASUREMENT";
var RERUN_ENV = "BROWSERSTACK_RERUN";
var TESTOPS_BUILD_COMPLETED_ENV = "BS_TESTOPS_BUILD_COMPLETED";
var BROWSERSTACK_ACCESSIBILITY = "BROWSERSTACK_ACCESSIBILITY";
var BROWSERSTACK_OBSERVABILITY = "BROWSERSTACK_OBSERVABILITY";
var MAX_GIT_META_DATA_SIZE_IN_BYTES = 64 * 1024;
var GIT_META_DATA_TRUNCATED = "...[TRUNCATED]";

// src/bstackLogger.ts
var log = logger("@wdio/browserstack-service");
var BStackLogger = class {
  static logFilePath = path.join(process.cwd(), LOGS_FILE);
  static logFolderPath = path.join(process.cwd(), "logs");
  static logFileStream;
  static logToFile(logMessage, logLevel) {
    try {
      if (!this.logFileStream) {
        this.ensureLogsFolder();
        this.logFileStream = fs.createWriteStream(this.logFilePath, { flags: "a" });
      }
      if (this.logFileStream && this.logFileStream.writable) {
        this.logFileStream.write(this.formatLog(logMessage, logLevel));
      }
    } catch (error) {
      log.debug(`Failed to log to file. Error ${error}`);
    }
  }
  static formatLog(logMessage, level) {
    return `${chalk.gray((/* @__PURE__ */ new Date()).toISOString())} ${chalk[COLORS[level]](level.toUpperCase())} ${chalk.whiteBright("@wdio/browserstack-service")} ${logMessage}
`;
  }
  static info(message) {
    this.logToFile(message, "info");
    log.info(message);
  }
  static error(message) {
    this.logToFile(message, "error");
    log.error(message);
  }
  static debug(message, param) {
    this.logToFile(message, "debug");
    if (param) {
      log.debug(message, param);
    } else {
      log.debug(message);
    }
  }
  static warn(message) {
    this.logToFile(message, "warn");
    log.warn(message);
  }
  static trace(message) {
    this.logToFile(message, "trace");
    log.trace(message);
  }
  static clearLogger() {
    if (this.logFileStream) {
      this.logFileStream.end();
    }
    this.logFileStream = null;
  }
  static clearLogFile() {
    if (fs.existsSync(this.logFilePath)) {
      fs.truncateSync(this.logFilePath);
    }
  }
  static ensureLogsFolder() {
    if (!fs.existsSync(this.logFolderPath)) {
      fs.mkdirSync(this.logFolderPath);
    }
  }
};

// src/performance-tester.ts
var PerformanceTester = class {
  static _observer;
  static _csvWriter;
  static _events = [];
  static started = false;
  static startMonitoring(csvName = "performance-report.csv") {
    this._observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        this._events.push(entry);
      });
    });
    this._observer.observe({ buffered: true, entryTypes: ["function"] });
    this.started = true;
    this._csvWriter = createObjectCsvWriter({
      path: csvName,
      header: [
        { id: "name", title: "Function Name" },
        { id: "time", title: "Execution Time (ms)" }
      ]
    });
  }
  static getPerformance() {
    return performance;
  }
  static calculateTimes(methods) {
    const times = {};
    this._events.map((entry) => {
      if (!times[entry.name]) {
        times[entry.name] = 0;
      }
      times[entry.name] += entry.duration;
    });
    const timeTaken = methods.reduce((a, c) => {
      return times[c] + (a || 0);
    }, 0);
    BStackLogger.info(`Time for ${methods} is ${timeTaken}`);
    return timeTaken;
  }
  static async stopAndGenerate(filename = "performance-own.html") {
    if (!this.started) {
      return;
    }
    await sleep(2e3);
    this._observer.disconnect();
    this.started = false;
    this.generateCSV(this._events);
    const content = this.generateReport(this._events);
    const path6 = process.cwd() + "/" + filename;
    fs2.writeFile(path6, content, (err) => {
      if (err) {
        BStackLogger.error(`Error in writing html ${err}`);
        return;
      }
      BStackLogger.info(`Performance report is at ${path6}`);
    });
  }
  static generateReport(entries) {
    let html = "<!DOCTYPE html><html><head><title>Performance Report</title></head><body>";
    html += "<h1>Performance Report</h1>";
    html += "<table><thead><tr><th>Function Name</th><th>Duration (ms)</th></tr></thead><tbody>";
    entries.forEach((entry) => {
      html += `<tr><td>${entry.name}</td><td>${entry.duration}</td></tr>`;
    });
    html += "</tbody></table></body></html>";
    return html;
  }
  static generateCSV(entries) {
    const times = {};
    entries.map((entry) => {
      if (!times[entry.name]) {
        times[entry.name] = 0;
      }
      times[entry.name] += entry.duration;
      return {
        name: entry.name,
        time: entry.duration
      };
    });
    const dat = Object.entries(times).map(([key, value]) => {
      return {
        name: key,
        time: value
      };
    });
    this._csvWriter.writeRecords(dat).then(() => BStackLogger.info("Performance CSV report generated successfully")).catch((error) => console.error(error));
  }
};

// src/testHub/utils.ts
var getProductMap = (config) => {
  return {
    observability: config.testObservability.enabled,
    accessibility: config.accessibility,
    percy: config.percy,
    automate: config.automate,
    app_automate: config.appAutomate
  };
};
var handleErrorForObservability = (error) => {
  process.env[BROWSERSTACK_OBSERVABILITY] = "false";
  logBuildError(error, "observability");
};
var handleErrorForAccessibility = (error) => {
  process.env[BROWSERSTACK_ACCESSIBILITY] = "false";
  logBuildError(error, "accessibility");
};
var logBuildError = (error, product = "") => {
  if (!error || !error.errors) {
    BStackLogger.error(`${product.toUpperCase()} Build creation failed ${error}`);
    return;
  }
  for (const errorJson of error.errors) {
    const errorType = errorJson.key;
    const errorMessage = errorJson.message;
    if (errorMessage) {
      switch (errorType) {
        case "ERROR_INVALID_CREDENTIALS":
          BStackLogger.error(errorMessage);
          break;
        case "ERROR_ACCESS_DENIED":
          BStackLogger.info(errorMessage);
          break;
        case "ERROR_SDK_DEPRECATED":
          BStackLogger.error(errorMessage);
          break;
        default:
          BStackLogger.error(errorMessage);
      }
    }
  }
};

// src/crash-reporter.ts
var CrashReporter = class {
  /* User test config for build run minus PII */
  static userConfigForReporting = {};
  /* User credentials used for reporting crashes in browserstack service */
  static credentialsForCrashReportUpload = {};
  static setCredentialsForCrashReportUpload(options, config) {
    this.credentialsForCrashReportUpload = {
      username: getObservabilityUser(options, config),
      password: getObservabilityKey(options, config)
    };
    process.env.CREDENTIALS_FOR_CRASH_REPORTING = JSON.stringify(this.credentialsForCrashReportUpload);
  }
  static setConfigDetails(userConfig, capabilities, options) {
    const configWithoutPII = this.filterPII(userConfig);
    const filteredCapabilities = this.filterCapabilities(capabilities);
    this.userConfigForReporting = {
      framework: userConfig.framework,
      services: configWithoutPII.services,
      capabilities: filteredCapabilities,
      env: {
        "BROWSERSTACK_BUILD": process.env.BROWSERSTACK_BUILD,
        "BROWSERSTACK_BUILD_NAME": process.env.BROWSERSTACK_BUILD_NAME,
        "BUILD_TAG": process.env.BUILD_TAG
      }
    };
    process.env.USER_CONFIG_FOR_REPORTING = JSON.stringify(this.userConfigForReporting);
    this.setCredentialsForCrashReportUpload(options, userConfig);
  }
  static async uploadCrashReport(exception, stackTrace) {
    try {
      if (!this.credentialsForCrashReportUpload.username || !this.credentialsForCrashReportUpload.password) {
        this.credentialsForCrashReportUpload = process.env.CREDENTIALS_FOR_CRASH_REPORTING !== void 0 ? JSON.parse(process.env.CREDENTIALS_FOR_CRASH_REPORTING) : this.credentialsForCrashReportUpload;
      }
    } catch (error) {
      return BStackLogger.error(`[Crash_Report_Upload] Failed to parse user credentials while reporting crash due to ${error}`);
    }
    if (!this.credentialsForCrashReportUpload.username || !this.credentialsForCrashReportUpload.password) {
      return BStackLogger.error("[Crash_Report_Upload] Failed to parse user credentials while reporting crash");
    }
    try {
      if (Object.keys(this.userConfigForReporting).length === 0) {
        this.userConfigForReporting = process.env.USER_CONFIG_FOR_REPORTING !== void 0 ? JSON.parse(process.env.USER_CONFIG_FOR_REPORTING) : {};
      }
    } catch (error) {
      BStackLogger.error(`[Crash_Report_Upload] Failed to parse user config while reporting crash due to ${error}`);
      this.userConfigForReporting = {};
    }
    const data = {
      hashed_id: process.env[BROWSERSTACK_TESTHUB_UUID],
      observability_version: {
        frameworkName: "WebdriverIO-" + (this.userConfigForReporting.framework || "null"),
        sdkVersion: BSTACK_SERVICE_VERSION
      },
      exception: {
        error: exception.toString(),
        stackTrace
      },
      config: this.userConfigForReporting
    };
    const url = `${DATA_ENDPOINT}/api/v1/analytics`;
    const encodedAuth = Buffer.from(`${this.credentialsForCrashReportUpload.username}:${this.credentialsForCrashReportUpload.password}`, "utf8").toString("base64");
    const headers = {
      ...DEFAULT_REQUEST_CONFIG.headers,
      Authorization: `Basic ${encodedAuth}`
    };
    const response = await fetch(url, {
      method: "POST",
      body: JSON.stringify(data),
      headers
    });
    if (response.ok) {
      BStackLogger.debug(`[Crash_Report_Upload] Success response: ${JSON.stringify(await response.json())}`);
    } else {
      BStackLogger.error(`[Crash_Report_Upload] Failed due to ${response.body}`);
    }
  }
  static recursivelyRedactKeysFromObject(obj, keys) {
    if (!obj) {
      return;
    }
    if (Array.isArray(obj)) {
      obj.map((ele) => this.recursivelyRedactKeysFromObject(ele, keys));
    } else {
      for (const prop in obj) {
        if (keys.includes(prop.toLowerCase())) {
          obj[prop] = "[REDACTED]";
        } else if (typeof obj[prop] === "object") {
          this.recursivelyRedactKeysFromObject(obj[prop], keys);
        }
      }
    }
  }
  static deletePIIKeysFromObject(obj) {
    if (!obj) {
      return;
    }
    ["user", "username", "key", "accessKey"].forEach((key) => delete obj[key]);
  }
  static filterCapabilities(capabilities) {
    const capsCopy = JSON.parse(JSON.stringify(capabilities));
    this.recursivelyRedactKeysFromObject(capsCopy, ["extensions"]);
    return capsCopy;
  }
  static filterPII(userConfig) {
    const configWithoutPII = JSON.parse(JSON.stringify(userConfig));
    this.deletePIIKeysFromObject(configWithoutPII);
    const finalServices = [];
    const initialServices = configWithoutPII.services;
    delete configWithoutPII.services;
    try {
      for (const serviceArray of initialServices) {
        if (Array.isArray(serviceArray) && serviceArray.length >= 2 && serviceArray[0] === "browserstack") {
          for (let idx = 1; idx < serviceArray.length; idx++) {
            this.deletePIIKeysFromObject(serviceArray[idx]);
            if (serviceArray[idx]) {
              this.deletePIIKeysFromObject(serviceArray[idx].testObservabilityOptions);
            }
          }
          finalServices.push(serviceArray);
          break;
        }
      }
    } catch (err) {
      BStackLogger.error(`Error in parsing user config PII with error ${err ? err.stack || err : err}`);
      return configWithoutPII;
    }
    configWithoutPII.services = finalServices;
    return configWithoutPII;
  }
};

// src/testOps/featureStats.ts
var FeatureStats = class _FeatureStats {
  triggeredCount = 0;
  sentCount = 0;
  failedCount = 0;
  groups = {};
  mark(status, groupId) {
    switch (status) {
      case "triggered":
        this.triggered(groupId);
        break;
      case "success":
      case "sent":
        this.sent(groupId);
        break;
      case "failed":
        this.failed(groupId);
        break;
      default:
        BStackLogger.debug("Request to mark usage for unknown status - " + status);
        break;
    }
  }
  triggered(groupId) {
    this.triggeredCount += 1;
    if (groupId) {
      this.createGroup(groupId).triggered();
    }
  }
  sent(groupId) {
    this.sentCount += 1;
    if (groupId) {
      this.createGroup(groupId).sent();
    }
  }
  failed(groupId) {
    this.failedCount += 1;
    if (groupId) {
      this.createGroup(groupId).failed();
    }
  }
  success(groupId) {
    this.sent(groupId);
  }
  createGroup(groupId) {
    if (!this.groups[groupId]) {
      this.groups[groupId] = new _FeatureStats();
    }
    return this.groups[groupId];
  }
  getTriggeredCount() {
    return this.triggeredCount;
  }
  getSentCount() {
    return this.sentCount;
  }
  getFailedCount() {
    return this.failedCount;
  }
  getUsageForGroup(groupId) {
    return this.groups[groupId] || new _FeatureStats();
  }
  getOverview() {
    return { triggeredCount: this.triggeredCount, sentCount: this.sentCount, failedCount: this.failedCount };
  }
  getGroups() {
    return this.groups;
  }
  add(featureStats) {
    this.triggeredCount += featureStats.getTriggeredCount();
    this.sentCount += featureStats.getSentCount();
    this.failedCount += featureStats.getFailedCount();
    Object.entries(featureStats.getGroups()).forEach(([groupId, group]) => {
      this.createGroup(groupId).add(group);
    });
  }
  // omitGroups: true/false -> Include groups or not
  // onlyGroups: true/false -> data includes only groups
  // nestedGroups: true/false -> groups will be nested in groups if true
  toJSON(config = {}) {
    const overviewData = !config.onlyGroups ? {
      triggeredCount: this.triggeredCount,
      sentCount: this.sentCount,
      failedCount: this.failedCount
    } : {};
    const groupsData = {};
    if (!config.omitGroups) {
      Object.entries(this.groups).forEach(([groupId, group2]) => {
        groupsData[groupId] = group2.toJSON();
      });
    }
    const group = config.nestedGroups ? { groups: groupsData } : groupsData;
    return {
      ...overviewData,
      ...group
    };
  }
  static fromJSON(json) {
    const stats = new _FeatureStats();
    if (!json || isObjectEmpty(json)) {
      return stats;
    }
    stats.triggeredCount = json.triggeredCount;
    stats.sentCount = json.sentCount;
    stats.failedCount = json.failedCount;
    if (!json.groups) {
      return stats;
    }
    Object.entries(json.groups).forEach(([groupId, group]) => {
      stats.groups[groupId] = _FeatureStats.fromJSON(group);
    });
    return stats;
  }
};
var featureStats_default = FeatureStats;

// src/testOps/featureUsage.ts
var FeatureUsage = class {
  isTriggered;
  status;
  error;
  constructor(isTriggered) {
    if (isTriggered !== void 0) {
      this.isTriggered = isTriggered;
    }
  }
  getTriggered() {
    return this.isTriggered;
  }
  setTriggered(triggered) {
    this.isTriggered = triggered;
  }
  setStatus(status) {
    this.status = status;
  }
  setError(error) {
    this.error = error;
  }
  triggered() {
    this.isTriggered = true;
  }
  failed(e) {
    this.status = "failed";
    this.error = getErrorString(e);
  }
  success() {
    this.status = "success";
  }
  getStatus() {
    return this.status;
  }
  getError() {
    return this.error;
  }
  toJSON() {
    return {
      isTriggered: this.isTriggered,
      status: this.status,
      error: this.error
    };
  }
};
var featureUsage_default = FeatureUsage;

// src/testOps/testOpsConfig.ts
var TestOpsConfig = class _TestOpsConfig {
  constructor(enabled = true, manuallySet = false) {
    this.enabled = enabled;
    this.manuallySet = manuallySet;
    _TestOpsConfig._instance = this;
  }
  static _instance;
  buildStopped = false;
  buildHashedId;
  static getInstance(...args) {
    if (!this._instance) {
      this._instance = new _TestOpsConfig(...args);
    }
    return this._instance;
  }
};
var testOpsConfig_default = TestOpsConfig;

// src/testOps/usageStats.ts
var UsageStats = class _UsageStats {
  static instance;
  testStartedStats;
  testFinishedStats;
  hookStartedStats;
  hookFinishedStats;
  cbtSessionStats;
  logStats;
  launchBuildUsage;
  stopBuildUsage;
  static getInstance() {
    if (!_UsageStats.instance) {
      _UsageStats.instance = new _UsageStats();
    }
    return _UsageStats.instance;
  }
  constructor() {
    this.testStartedStats = new featureStats_default();
    this.testFinishedStats = new featureStats_default();
    this.hookStartedStats = new featureStats_default();
    this.hookFinishedStats = new featureStats_default();
    this.cbtSessionStats = new featureStats_default();
    this.logStats = new featureStats_default();
    this.launchBuildUsage = new featureUsage_default();
    this.stopBuildUsage = new featureUsage_default();
  }
  add(usageStats) {
    this.testStartedStats.add(usageStats.testStartedStats);
    this.testFinishedStats.add(usageStats.testFinishedStats);
    this.hookStartedStats.add(usageStats.hookStartedStats);
    this.hookFinishedStats.add(usageStats.hookFinishedStats);
    this.cbtSessionStats.add(usageStats.cbtSessionStats);
    this.logStats.add(usageStats.logStats);
  }
  getFormattedData(workersData) {
    this.addDataFromWorkers(workersData);
    const testOpsConfig = testOpsConfig_default.getInstance();
    const usage = {
      enabled: testOpsConfig.enabled,
      manuallySet: testOpsConfig.manuallySet,
      buildHashedId: testOpsConfig.buildHashedId
    };
    if (!usage.enabled) {
      return usage;
    }
    try {
      usage.events = this.getEventsData();
    } catch (e) {
      BStackLogger.debug("exception in getFormattedData: " + e);
    }
    return usage;
  }
  addDataFromWorkers(workersData) {
    workersData.map((workerData) => {
      try {
        const usageStatsForWorker = _UsageStats.fromJSON(workerData.usageStats);
        this.add(usageStatsForWorker);
      } catch (e) {
        BStackLogger.debug("Exception in adding workerData: " + e);
      }
    });
  }
  getEventsData() {
    return {
      buildEvents: {
        started: this.launchBuildUsage.toJSON(),
        finished: this.stopBuildUsage.toJSON()
      },
      testEvents: {
        started: this.testStartedStats.toJSON(),
        finished: this.testFinishedStats.toJSON({ omitGroups: true }),
        ...this.testFinishedStats.toJSON({ onlyGroups: true })
      },
      hookEvents: {
        started: this.hookStartedStats.toJSON(),
        finished: this.hookFinishedStats.toJSON({ omitGroups: true }),
        ...this.hookFinishedStats.toJSON({ onlyGroups: true })
      },
      logEvents: this.logStats.toJSON(),
      cbtSessionEvents: this.cbtSessionStats.toJSON()
    };
  }
  getDataToSave() {
    return {
      testEvents: {
        started: this.testStartedStats.toJSON(),
        finished: this.testFinishedStats.toJSON({ nestedGroups: true })
      },
      hookEvents: {
        started: this.hookStartedStats.toJSON(),
        finished: this.hookFinishedStats.toJSON({ nestedGroups: true })
      },
      logEvents: this.logStats.toJSON({ nestedGroups: true }),
      cbtSessionEvents: this.cbtSessionStats.toJSON()
    };
  }
  static fromJSON(data) {
    const usageStats = new _UsageStats();
    usageStats.testStartedStats = featureStats_default.fromJSON(data.testEvents.started);
    usageStats.testFinishedStats = featureStats_default.fromJSON(data.testEvents.finished);
    usageStats.hookStartedStats = featureStats_default.fromJSON(data.hookEvents.started);
    usageStats.hookFinishedStats = featureStats_default.fromJSON(data.hookEvents.finished);
    usageStats.logStats = featureStats_default.fromJSON(data.logEvents);
    usageStats.cbtSessionStats = featureStats_default.fromJSON(data.cbtSessionStats);
    return usageStats;
  }
};
var usageStats_default = UsageStats;

// src/scripts/accessibility-scripts.ts
import path2 from "node:path";
import fs3 from "node:fs";
import os from "node:os";
var AccessibilityScripts = class _AccessibilityScripts {
  static instance = null;
  performScan = null;
  getResults = null;
  getResultsSummary = null;
  saveTestResults = null;
  commandsToWrap = null;
  browserstackFolderPath = "";
  commandsPath = "";
  // don't allow to create instances from it other than through `checkAndGetInstance`
  constructor() {
    this.browserstackFolderPath = this.getWritableDir();
    this.commandsPath = path2.join(this.browserstackFolderPath, "commands.json");
  }
  static checkAndGetInstance() {
    if (!_AccessibilityScripts.instance) {
      _AccessibilityScripts.instance = new _AccessibilityScripts();
      _AccessibilityScripts.instance.readFromExistingFile();
    }
    return _AccessibilityScripts.instance;
  }
  /* eslint-disable @typescript-eslint/no-unused-vars */
  getWritableDir() {
    const orderedPaths = [
      path2.join(os.homedir(), ".browserstack"),
      process.cwd(),
      os.tmpdir()
    ];
    for (const orderedPath of orderedPaths) {
      try {
        if (fs3.existsSync(orderedPath)) {
          fs3.accessSync(orderedPath);
          return orderedPath;
        }
        fs3.mkdirSync(orderedPath, { recursive: true });
        return orderedPath;
      } catch (error) {
      }
    }
    return "";
  }
  readFromExistingFile() {
    try {
      if (fs3.existsSync(this.commandsPath)) {
        const data = fs3.readFileSync(this.commandsPath, "utf8");
        if (data) {
          this.update(JSON.parse(data));
        }
      }
    } catch {
    }
  }
  update(data) {
    if (data.scripts) {
      this.performScan = data.scripts.scan;
      this.getResults = data.scripts.getResults;
      this.getResultsSummary = data.scripts.getResultsSummary;
      this.saveTestResults = data.scripts.saveResults;
    }
    if (data.commands && data.commands.length) {
      this.commandsToWrap = data.commands;
    }
  }
  store() {
    if (!fs3.existsSync(this.browserstackFolderPath)) {
      fs3.mkdirSync(this.browserstackFolderPath);
    }
    fs3.writeFileSync(this.commandsPath, JSON.stringify({
      commands: this.commandsToWrap,
      scripts: {
        scan: this.performScan,
        getResults: this.getResults,
        getResultsSummary: this.getResultsSummary,
        saveResults: this.saveTestResults
      }
    }));
  }
};
var accessibility_scripts_default = AccessibilityScripts.checkAndGetInstance();

// src/util.ts
var pGitconfig = promisify(gitconfig);
var DEFAULT_REQUEST_CONFIG = {
  headers: {
    "Content-Type": "application/json",
    "X-BSTACK-OBS": "true"
  }
};
var COLORS = {
  error: "red",
  warn: "yellow",
  info: "cyanBright",
  debug: "green",
  trace: "cyan",
  progress: "magenta"
};
function processError(error, fn, args) {
  BStackLogger.error(`Error in executing ${fn.name} with args ${args}: ${error}`);
  let argsString;
  try {
    argsString = JSON.stringify(args);
  } catch {
    argsString = util.inspect(args, { depth: 2 });
  }
  CrashReporter.uploadCrashReport(`Error in executing ${fn.name} with args ${argsString} : ${error}`, error && error.stack || "unknown error");
}
function o11yErrorHandler(fn) {
  return function(...args) {
    try {
      let functionToHandle = fn;
      if (process.env[PERF_MEASUREMENT_ENV]) {
        functionToHandle = PerformanceTester.getPerformance().timerify(functionToHandle);
      }
      const result = functionToHandle(...args);
      if (result instanceof Promise) {
        return result.catch((error) => processError(error, fn, args));
      }
      return result;
    } catch (error) {
      processError(error, fn, args);
    }
  };
}
var processTestObservabilityResponse = (response) => {
  if (!response.observability) {
    handleErrorForObservability(null);
    return;
  }
  if (!response.observability.success) {
    handleErrorForObservability(response.observability);
    return;
  }
  process.env[BROWSERSTACK_OBSERVABILITY] = "true";
  if (response.observability.options.allow_screenshots) {
    process.env[TESTOPS_SCREENSHOT_ENV] = response.observability.options.allow_screenshots.toString();
  }
};
var jsonifyAccessibilityArray = (dataArray, keyName, valueName) => {
  const result = {};
  dataArray.forEach((element) => {
    result[element[keyName]] = element[valueName];
  });
  return result;
};
var processAccessibilityResponse = (response) => {
  if (!response.accessibility) {
    handleErrorForAccessibility(null);
    return;
  }
  if (!response.accessibility.success) {
    handleErrorForAccessibility(response.accessibility);
    return;
  }
  if (response.accessibility.options) {
    const { accessibilityToken, pollingTimeout, scannerVersion } = jsonifyAccessibilityArray(response.accessibility.options.capabilities, "name", "value");
    const scriptsJson = {
      "scripts": jsonifyAccessibilityArray(response.accessibility.options.scripts, "name", "command"),
      "commands": response.accessibility.options.commandsToWrap.commands
    };
    if (scannerVersion) {
      process.env.BSTACK_A11Y_SCANNER_VERSION = scannerVersion;
      BStackLogger.debug(`Accessibility scannerVersion ${scannerVersion}`);
    }
    if (accessibilityToken) {
      process.env.BSTACK_A11Y_JWT = accessibilityToken;
      process.env[BROWSERSTACK_ACCESSIBILITY] = "true";
    }
    if (pollingTimeout) {
      process.env.BSTACK_A11Y_POLLING_TIMEOUT = pollingTimeout;
    }
    if (scriptsJson) {
      accessibility_scripts_default.update(scriptsJson);
      accessibility_scripts_default.store();
    }
  }
};
var processLaunchBuildResponse = (response, options) => {
  if (options.testObservability) {
    processTestObservabilityResponse(response);
  }
  if (options.accessibility) {
    processAccessibilityResponse(response);
  }
};
var launchTestSession = o11yErrorHandler(async function launchTestSession2(options, config, bsConfig, bStackConfig) {
  const launchBuildUsage = usageStats_default.getInstance().launchBuildUsage;
  launchBuildUsage.triggered();
  const data = {
    format: "json",
    project_name: getObservabilityProject(options, bsConfig.projectName),
    name: getObservabilityBuild(options, bsConfig.buildName),
    build_identifier: bsConfig.buildIdentifier,
    started_at: (/* @__PURE__ */ new Date()).toISOString(),
    tags: getObservabilityBuildTags(options, bsConfig.buildTag),
    host_info: {
      hostname: hostname(),
      platform: platform(),
      type: type(),
      version: version(),
      arch: arch()
    },
    ci_info: getCiInfo(),
    build_run_identifier: process.env.BROWSERSTACK_BUILD_RUN_IDENTIFIER,
    failed_tests_rerun: process.env[RERUN_ENV] || false,
    version_control: await getGitMetaData(),
    accessibility: {
      settings: options.accessibilityOptions
    },
    browserstackAutomation: shouldAddServiceVersion(config, options.testObservability),
    framework_details: {
      frameworkName: "WebdriverIO-" + config.framework,
      frameworkVersion: bsConfig.bstackServiceVersion,
      sdkVersion: bsConfig.bstackServiceVersion,
      language: "ECMAScript",
      testFramework: {
        name: "WebdriverIO",
        version: bsConfig.bstackServiceVersion
      }
    },
    product_map: getProductMap(bStackConfig),
    config: {}
  };
  try {
    if (Object.keys(CrashReporter.userConfigForReporting).length === 0) {
      CrashReporter.userConfigForReporting = process.env.USER_CONFIG_FOR_REPORTING !== void 0 ? JSON.parse(process.env.USER_CONFIG_FOR_REPORTING) : {};
    }
  } catch (error) {
    return BStackLogger.error(`[Crash_Report_Upload] Failed to parse user config while sending build start event due to ${error}`);
  }
  data.config = CrashReporter.userConfigForReporting;
  try {
    const url = `${DATA_ENDPOINT}/api/v2/builds`;
    const encodedAuth = Buffer.from(`${getObservabilityUser(options, config)}:${getObservabilityKey(options, config)}`, "utf8").toString("base64");
    const headers = {
      ...DEFAULT_REQUEST_CONFIG.headers,
      Authorization: `Basic ${encodedAuth}`
    };
    const response = await fetch(url, {
      method: "POST",
      headers,
      body: JSON.stringify(data)
    });
    const jsonResponse = await response.json();
    BStackLogger.debug(`[Start_Build] Success response: ${JSON.stringify(jsonResponse)}`);
    process.env[TESTOPS_BUILD_COMPLETED_ENV] = "true";
    if (jsonResponse.jwt) {
      process.env[BROWSERSTACK_TESTHUB_JWT] = jsonResponse.jwt;
    }
    if (jsonResponse.build_hashed_id) {
      process.env[BROWSERSTACK_TESTHUB_UUID] = jsonResponse.build_hashed_id;
      testOpsConfig_default.getInstance().buildHashedId = jsonResponse.build_hashed_id;
    }
    processLaunchBuildResponse(jsonResponse, options);
    launchBuildUsage.success();
  } catch (error) {
    BStackLogger.debug(`TestHub build start failed: ${format(error)}`);
    if (!error.success) {
      launchBuildUsage.failed(error);
      logBuildError(error);
      return;
    }
  }
});
var stopBuildUpstream = o11yErrorHandler(async function stopBuildUpstream2() {
  const stopBuildUsage = usageStats_default.getInstance().stopBuildUsage;
  stopBuildUsage.triggered();
  if (!process.env[TESTOPS_BUILD_COMPLETED_ENV]) {
    stopBuildUsage.failed("Build is not completed yet");
    return {
      status: "error",
      message: "Build is not completed yet"
    };
  }
  if (!process.env[BROWSERSTACK_TESTHUB_JWT]) {
    stopBuildUsage.failed("Token/buildID is undefined, build creation might have failed");
    BStackLogger.debug("[STOP_BUILD] Missing Authentication Token/ Build ID");
    return {
      status: "error",
      message: "Token/buildID is undefined, build creation might have failed"
    };
  }
  const data = {
    "stop_time": (/* @__PURE__ */ new Date()).toISOString()
  };
  try {
    const url = `${DATA_ENDPOINT}/api/v1/builds/${process.env[BROWSERSTACK_TESTHUB_UUID]}/stop`;
    const response = await fetch(url, {
      method: "PUT",
      headers: {
        ...DEFAULT_REQUEST_CONFIG.headers,
        "Authorization": `Bearer ${process.env[BROWSERSTACK_TESTHUB_JWT]}`
      },
      body: JSON.stringify(data)
    });
    BStackLogger.debug(`[STOP_BUILD] Success response: ${await response.text()}`);
    stopBuildUsage.success();
    return {
      status: "success",
      message: ""
    };
  } catch (error) {
    stopBuildUsage.failed(error);
    BStackLogger.debug(`[STOP_BUILD] Failed. Error: ${error}`);
    return {
      status: "error",
      message: error.message
    };
  }
});
function getCiInfo() {
  const env = process.env;
  if (typeof env.JENKINS_URL === "string" && env.JENKINS_URL.length > 0 || typeof env.JENKINS_HOME === "string" && env.JENKINS_HOME.length > 0) {
    return {
      name: "Jenkins",
      build_url: env.BUILD_URL,
      job_name: env.JOB_NAME,
      build_number: env.BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && isTrue(env.CIRCLECI)) {
    return {
      name: "CircleCI",
      build_url: env.CIRCLE_BUILD_URL,
      job_name: env.CIRCLE_JOB,
      build_number: env.CIRCLE_BUILD_NUM
    };
  }
  if (isTrue(env.CI) && isTrue(env.TRAVIS)) {
    return {
      name: "Travis CI",
      build_url: env.TRAVIS_BUILD_WEB_URL,
      job_name: env.TRAVIS_JOB_NAME,
      build_number: env.TRAVIS_BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && env.CI_NAME === "codeship") {
    return {
      name: "Codeship",
      build_url: null,
      job_name: null,
      build_number: null
    };
  }
  if (env.BITBUCKET_BRANCH && env.BITBUCKET_COMMIT) {
    return {
      name: "Bitbucket",
      build_url: env.BITBUCKET_GIT_HTTP_ORIGIN,
      job_name: null,
      build_number: env.BITBUCKET_BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && isTrue(env.DRONE)) {
    return {
      name: "Drone",
      build_url: env.DRONE_BUILD_LINK,
      job_name: null,
      build_number: env.DRONE_BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && isTrue(env.SEMAPHORE)) {
    return {
      name: "Semaphore",
      build_url: env.SEMAPHORE_ORGANIZATION_URL,
      job_name: env.SEMAPHORE_JOB_NAME,
      build_number: env.SEMAPHORE_JOB_ID
    };
  }
  if (isTrue(env.CI) && isTrue(env.GITLAB_CI)) {
    return {
      name: "GitLab",
      build_url: env.CI_JOB_URL,
      job_name: env.CI_JOB_NAME,
      build_number: env.CI_JOB_ID
    };
  }
  if (isTrue(env.CI) && isTrue(env.BUILDKITE)) {
    return {
      name: "Buildkite",
      build_url: env.BUILDKITE_BUILD_URL,
      job_name: env.BUILDKITE_LABEL || env.BUILDKITE_PIPELINE_NAME,
      build_number: env.BUILDKITE_BUILD_NUMBER
    };
  }
  if (isTrue(env.TF_BUILD) && env.TF_BUILD_BUILDNUMBER) {
    return {
      name: "Visual Studio Team Services",
      build_url: `${env.SYSTEM_TEAMFOUNDATIONSERVERURI}${env.SYSTEM_TEAMPROJECTID}`,
      job_name: env.SYSTEM_DEFINITIONID,
      build_number: env.BUILD_BUILDID
    };
  }
  if (isTrue(env.APPVEYOR)) {
    return {
      name: "Appveyor",
      build_url: `${env.APPVEYOR_URL}/project/${env.APPVEYOR_ACCOUNT_NAME}/${env.APPVEYOR_PROJECT_SLUG}/builds/${env.APPVEYOR_BUILD_ID}`,
      job_name: env.APPVEYOR_JOB_NAME,
      build_number: env.APPVEYOR_BUILD_NUMBER
    };
  }
  if (env.AZURE_HTTP_USER_AGENT && env.TF_BUILD) {
    return {
      name: "Azure CI",
      build_url: `${env.SYSTEM_TEAMFOUNDATIONSERVERURI}${env.SYSTEM_TEAMPROJECT}/_build/results?buildId=${env.BUILD_BUILDID}`,
      job_name: env.BUILD_BUILDID,
      build_number: env.BUILD_BUILDID
    };
  }
  if (env.CODEBUILD_BUILD_ID || env.CODEBUILD_RESOLVED_SOURCE_VERSION || env.CODEBUILD_SOURCE_VERSION) {
    return {
      name: "AWS CodeBuild",
      build_url: env.CODEBUILD_PUBLIC_BUILD_URL,
      job_name: env.CODEBUILD_BUILD_ID,
      build_number: env.CODEBUILD_BUILD_ID
    };
  }
  if (env.bamboo_buildNumber) {
    return {
      name: "Bamboo",
      build_url: env.bamboo_buildResultsUrl,
      job_name: env.bamboo_shortJobName,
      build_number: env.bamboo_buildNumber
    };
  }
  if (env.WERCKER || env.WERCKER_MAIN_PIPELINE_STARTED) {
    return {
      name: "Wercker",
      build_url: env.WERCKER_BUILD_URL,
      job_name: env.WERCKER_MAIN_PIPELINE_STARTED ? "Main Pipeline" : null,
      build_number: env.WERCKER_GIT_COMMIT
    };
  }
  if (env.GCP_PROJECT || env.GCLOUD_PROJECT || env.GOOGLE_CLOUD_PROJECT) {
    return {
      name: "Google Cloud",
      build_url: null,
      job_name: env.PROJECT_ID,
      build_number: env.BUILD_ID
    };
  }
  if (env.SHIPPABLE) {
    return {
      name: "Shippable",
      build_url: env.SHIPPABLE_BUILD_URL,
      job_name: env.SHIPPABLE_JOB_ID ? `Job #${env.SHIPPABLE_JOB_ID}` : null,
      build_number: env.SHIPPABLE_BUILD_NUMBER
    };
  }
  if (isTrue(env.NETLIFY)) {
    return {
      name: "Netlify",
      build_url: env.DEPLOY_URL,
      job_name: env.SITE_NAME,
      build_number: env.BUILD_ID
    };
  }
  if (isTrue(env.GITHUB_ACTIONS)) {
    return {
      name: "GitHub Actions",
      build_url: `${env.GITHUB_SERVER_URL}/${env.GITHUB_REPOSITORY}/actions/runs/${env.GITHUB_RUN_ID}`,
      job_name: env.GITHUB_WORKFLOW,
      build_number: env.GITHUB_RUN_ID
    };
  }
  if (isTrue(env.CI) && env.VERCEL === "1") {
    return {
      name: "Vercel",
      build_url: `http://${env.VERCEL_URL}`,
      job_name: null,
      build_number: null
    };
  }
  if (env.TEAMCITY_VERSION) {
    return {
      name: "Teamcity",
      build_url: null,
      job_name: null,
      build_number: env.BUILD_NUMBER
    };
  }
  if (env.CONCOURSE || env.CONCOURSE_URL || env.CONCOURSE_USERNAME || env.CONCOURSE_TEAM) {
    return {
      name: "Concourse",
      build_url: null,
      job_name: env.BUILD_JOB_NAME || null,
      build_number: env.BUILD_ID || null
    };
  }
  if (env.GO_JOB_NAME) {
    return {
      name: "GoCD",
      build_url: null,
      job_name: env.GO_JOB_NAME,
      build_number: env.GO_PIPELINE_COUNTER
    };
  }
  if (env.CF_BUILD_ID) {
    return {
      name: "CodeFresh",
      build_url: env.CF_BUILD_URL,
      job_name: env.CF_PIPELINE_NAME,
      build_number: env.CF_BUILD_ID
    };
  }
  return null;
}
async function getGitMetaData() {
  const info = gitRepoInfo();
  if (!info.commonGitDir) {
    return;
  }
  const { remote } = await pGitconfig(info.commonGitDir);
  const remotes = remote ? Object.keys(remote).map((remoteName) => ({ name: remoteName, url: remote[remoteName].url })) : [];
  let gitMetaData = {
    name: "git",
    sha: info.sha,
    short_sha: info.abbreviatedSha,
    branch: info.branch,
    tag: info.tag,
    committer: info.committer,
    committer_date: info.committerDate,
    author: info.author,
    author_date: info.authorDate,
    commit_message: info.commitMessage,
    root: info.root,
    common_git_dir: info.commonGitDir,
    worktree_git_dir: info.worktreeGitDir,
    last_tag: info.lastTag,
    commits_since_last_tag: info.commitsSinceLastTag,
    remotes
  };
  gitMetaData = checkAndTruncateVCSInfo(gitMetaData);
  return gitMetaData;
}
function isBStackSession(config) {
  if (typeof config.user === "string" && typeof config.key === "string" && config.key.length === 20) {
    return true;
  }
  return false;
}
function isBrowserstackInfra(config, caps) {
  const isBrowserstack = (str) => {
    return str.includes("browserstack.com");
  };
  if (config.hostname && !isBrowserstack(config.hostname)) {
    return false;
  }
  if (caps && typeof caps === "object") {
    if (Array.isArray(caps)) {
      for (const capability of caps) {
        if (capability.hostname && !isBrowserstack(capability.hostname)) {
          return false;
        }
      }
    } else {
      for (const key in caps) {
        const capability = caps[key];
        if (capability.hostname && !isBrowserstack(capability.hostname)) {
          return false;
        }
      }
    }
  }
  if (!isBStackSession(config)) {
    return false;
  }
  return true;
}
function shouldAddServiceVersion(config, testObservability, caps) {
  if (config.services && config.services.toString().includes("chromedriver") && testObservability !== false || !isBrowserstackInfra(config, caps)) {
    return false;
  }
  return true;
}
function getObservabilityUser(options, config) {
  if (process.env.BROWSERSTACK_USERNAME) {
    return process.env.BROWSERSTACK_USERNAME;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.user) {
    return options.testObservabilityOptions.user;
  }
  return config.user;
}
function getObservabilityKey(options, config) {
  if (process.env.BROWSERSTACK_ACCESS_KEY) {
    return process.env.BROWSERSTACK_ACCESS_KEY;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.key) {
    return options.testObservabilityOptions.key;
  }
  return config.key;
}
function getObservabilityProject(options, bstackProjectName) {
  if (process.env.TEST_OBSERVABILITY_PROJECT_NAME) {
    return process.env.TEST_OBSERVABILITY_PROJECT_NAME;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.projectName) {
    return options.testObservabilityOptions.projectName;
  }
  return bstackProjectName;
}
function getObservabilityBuild(options, bstackBuildName) {
  if (process.env.TEST_OBSERVABILITY_BUILD_NAME) {
    return process.env.TEST_OBSERVABILITY_BUILD_NAME;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.buildName) {
    return options.testObservabilityOptions.buildName;
  }
  return bstackBuildName || path3.basename(path3.resolve(process.cwd()));
}
function getObservabilityBuildTags(options, bstackBuildTag) {
  if (process.env.TEST_OBSERVABILITY_BUILD_TAG) {
    return process.env.TEST_OBSERVABILITY_BUILD_TAG.split(",");
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.buildTag) {
    return options.testObservabilityOptions.buildTag;
  }
  if (bstackBuildTag) {
    return [bstackBuildTag];
  }
  return [];
}
function isTrue(value) {
  return (value + "").toLowerCase() === "true";
}
var patchConsoleLogs = o11yErrorHandler(() => {
  const BSTestOpsPatcher = new logPatcher_default({});
  Object.keys(consoleHolder).forEach((method) => {
    const origMethod = console[method].bind(console);
    if (typeof console[method] === "function" && method !== "Console") {
      console[method] = (...args) => {
        origMethod(...args);
        BSTestOpsPatcher[method](...args);
      };
    }
  });
});
var sleep = (ms = 100) => new Promise((resolve) => setTimeout(resolve, ms));
var getPlatformVersion = o11yErrorHandler(function getPlatformVersion2(caps) {
  if (!caps) {
    return void 0;
  }
  const bstackOptions = caps?.["bstack:options"];
  const keys = ["platformVersion", "platform_version", "osVersion", "os_version"];
  for (const key of keys) {
    if (bstackOptions && bstackOptions?.[key]) {
      return String(bstackOptions?.[key]);
    } else if (caps[key]) {
      return String(caps[key]);
    }
  }
  return void 0;
});
var isObjectEmpty = (objectName) => {
  return objectName && Object.keys(objectName).length === 0 && objectName.constructor === Object;
};
var getErrorString = (err) => {
  if (!err) {
    return void 0;
  }
  if (typeof err === "string") {
    return err;
  } else if (err instanceof Error) {
    return err.message;
  }
};
function truncateString(field, truncateSizeInBytes) {
  try {
    const bufferSizeInBytes = Buffer.from(GIT_META_DATA_TRUNCATED).length;
    const fieldBufferObj = Buffer.from(field);
    const lenOfFieldBufferObj = fieldBufferObj.length;
    const finalLen = Math.ceil(lenOfFieldBufferObj - truncateSizeInBytes - bufferSizeInBytes);
    if (finalLen > 0) {
      const truncatedString = fieldBufferObj.subarray(0, finalLen).toString() + GIT_META_DATA_TRUNCATED;
      return truncatedString;
    }
  } catch (error) {
    BStackLogger.debug(`Error while truncating field, nothing was truncated here: ${error}`);
  }
  return field;
}
function getSizeOfJsonObjectInBytes(jsonData) {
  try {
    const buffer = Buffer.from(JSON.stringify(jsonData));
    return buffer.length;
  } catch (error) {
    BStackLogger.debug(`Something went wrong while calculating size of JSON object: ${error}`);
  }
  return -1;
}
function checkAndTruncateVCSInfo(gitMetaData) {
  const gitMetaDataSizeInBytes = getSizeOfJsonObjectInBytes(gitMetaData);
  if (gitMetaDataSizeInBytes && gitMetaDataSizeInBytes > MAX_GIT_META_DATA_SIZE_IN_BYTES) {
    const truncateSize = gitMetaDataSizeInBytes - MAX_GIT_META_DATA_SIZE_IN_BYTES;
    const truncatedCommitMessage = truncateString(gitMetaData.commit_message, truncateSize);
    gitMetaData.commit_message = truncatedCommitMessage;
    BStackLogger.info(`The commit has been truncated. Size of commit after truncation is ${getSizeOfJsonObjectInBytes(gitMetaData) / 1024} KB`);
  }
  return gitMetaData;
}

// src/cleanup.ts
import fs7 from "node:fs";

// src/instrumentation/funnelInstrumentation.ts
import os2 from "node:os";
import util2, { format as format2 } from "node:util";
import path5 from "node:path";
import fs6 from "node:fs";

// src/data-store.ts
import path4 from "node:path";
import fs5 from "node:fs";
var workersDataDirPath = path4.join(process.cwd(), "logs", "worker_data");

// src/fetchWrapper.ts
var ResponseError = class extends Error {
  response;
  constructor(message, res) {
    super(message);
    this.response = res;
  }
};
async function fetchWrap(input, init) {
  const res = await fetch(input, init);
  if (!res.ok) {
    throw new ResponseError(`Error response from server ${res.status}:  ${await res.text()}`, res);
  }
  return res;
}

// src/instrumentation/funnelInstrumentation.ts
function redactCredentialsFromFunnelData(data) {
  if (data) {
    if (data.userName) {
      data.userName = "[REDACTED]";
    }
    if (data.accessKey) {
      data.accessKey = "[REDACTED]";
    }
  }
  return data;
}
async function fireFunnelRequest(data) {
  const { userName, accessKey } = data;
  redactCredentialsFromFunnelData(data);
  BStackLogger.debug("Sending SDK event with data " + util2.inspect(data, { depth: 6 }));
  const encodedAuth = Buffer.from(`${userName}:${accessKey}`, "utf8").toString("base64");
  const response = await fetchWrap(FUNNEL_INSTRUMENTATION_URL, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      Authorization: `Basic ${encodedAuth}`
    },
    body: JSON.stringify(data)
  });
  BStackLogger.debug("Funnel Event Response: " + JSON.stringify(await response.text()));
}

// src/cleanup.ts
var BStackCleanup = class _BStackCleanup {
  static async startCleanup() {
    try {
      const funnelDataCleanup = process.argv.includes("--funnelData");
      let funnelData = null;
      if (funnelDataCleanup) {
        const index = process.argv.indexOf("--funnelData");
        const filePath = process.argv[index + 1];
        funnelData = _BStackCleanup.getFunnelDataFromFile(filePath);
      }
      if (process.argv.includes("--observability") && funnelData) {
        await this.executeObservabilityCleanup(funnelData);
      }
      if (funnelDataCleanup && funnelData) {
        await this.sendFunnelData(funnelData);
      }
    } catch (err) {
      const error = err;
      BStackLogger.error(error);
    }
  }
  static async executeObservabilityCleanup(funnelData) {
    if (!process.env[BROWSERSTACK_TESTHUB_JWT]) {
      return;
    }
    BStackLogger.debug("Executing observability cleanup");
    try {
      const result = await stopBuildUpstream();
      if (process.env[BROWSERSTACK_OBSERVABILITY] && process.env[BROWSERSTACK_TESTHUB_UUID]) {
        BStackLogger.info(`
Visit https://observability.browserstack.com/builds/${process.env[BROWSERSTACK_TESTHUB_UUID]} to view build report, insights, and many more debugging information all at one place!
`);
      }
      const status = result && result.status || "failed";
      const message = result && result.message;
      this.updateO11yStopData(funnelData, status, status === "failed" ? message : void 0);
    } catch (e) {
      BStackLogger.error("Error in stopping Observability build: " + e);
      this.updateO11yStopData(funnelData, "failed", e);
    }
  }
  static updateO11yStopData(funnelData, status, error = void 0) {
    const toData = funnelData?.event_properties?.productUsage?.testObservability;
    if (!toData) {
      return;
    }
    let existingStopData = toData.events.buildEvents.finished;
    existingStopData = existingStopData || {};
    existingStopData = {
      ...existingStopData,
      status,
      error: getErrorString(error),
      stoppedFrom: "exitHook"
    };
    toData.events.buildEvents.finished = existingStopData;
  }
  static async sendFunnelData(funnelData) {
    try {
      await fireFunnelRequest(funnelData);
      BStackLogger.debug("Funnel data sent successfully from cleanup");
    } catch (e) {
      BStackLogger.error("Error in sending funnel data: " + e);
    }
  }
  static getFunnelDataFromFile(filePath) {
    if (!filePath) {
      return null;
    }
    const content = fs7.readFileSync(filePath, "utf8");
    const data = JSON.parse(content);
    this.removeFunnelDataFile(filePath);
    return data;
  }
  static removeFunnelDataFile(filePath) {
    if (!filePath) {
      return;
    }
    fs7.rmSync(filePath, { force: true });
  }
};
await BStackCleanup.startCleanup();
export {
  BStackCleanup as default
};
